function participant_analysis_pipeline()
% PARTICIPANT_ANALYSIS_PIPELINE perform the full PLD experiment analysis.
%   Requires a "raw_participant_data" directory in the current directory
%   
%   Requires .csv data files from Gorilla. Note that if you have newly
%   downloaded the data from Gorilla, you will need to manually remove the
%   "END OF FILE" line that Gorilla puts in the last row of their .csv
%   files.

results = get_results_struct();

raw_data_path = './raw_participant_data/';
processed_data_path = './participant_data_processed/';

%% Clean-up relevant Participant Information
% 'data_exp_58996-v8_questionnaire-39n8.csv' is the data file of the 
%informed consent that is generated by Gorilla
pp_information = readtable(strcat(raw_data_path, 'data_exp_58996-v8_questionnaire-39n8.csv'));

% we are only interested in the following information
Tb = pp_information(:,{'ParticipantPrivateID','ParticipantMonitorSize','UTCDate','QuestionKey','Response'});
Tb.QuestionKey = categorical(Tb.QuestionKey);
Tb.ParticipantMonitorSize = categorical(Tb.ParticipantMonitorSize);

%hacky; Pick the first UTCLocalDate for each participant and fill for the
%other rows of that participant, since we are only interested in when they
%started the experiment
lastID = 0;
for i= 1:1:size(Tb,1)
    if(Tb{i,{'ParticipantPrivateID'}} ~= lastID)
        lastID = Tb{i,{'ParticipantPrivateID'}};
        date = Tb{i,{'UTCDate'}};
    else
        Tb.UTCDate(i) = date;
    end
end

%transform from a long to wide table
TbU = unstack(Tb,'Response','QuestionKey', "AggregationFunction", @unique);
%remove variables that we do not need
TbU = removevars(TbU,{'BEGINQUESTIONNAIRE', 'ENDQUESTIONNAIRE', 'informedconsent_response_quantised' ...
    'informedconsent_date_day', 'informedconsent_date_month', 'informedconsent_date_year'});

TbU.Properties.VariableNames = {'ID', 'MonitorSize', 'StartUTCDateTime', 'Name', 'InformedConsentResponse'};
pp_info = TbU;

results.Experiment2.ParticipantInfo = pp_info;

%% Load and transform old experiment results (Experiment 1)
if exist('old_perceiver_results.mat','file') ~= 2
    error("You have no old results .mat file! ('old_perceiver_results.mat')");
else
    load(strcat(raw_data_path, 'old_perceiver_results.mat'), 'tbl_E_pscores')
end

old_res = tbl_E_pscores;

idx_sagittal = old_res.perspective == categorical(2);
old_res = old_res(idx_sagittal,:);

idx_walking = old_res.speed == categorical(1);
old_res = old_res(idx_walking,:);

old_res = removevars(old_res, {'speed','perspective'});

results.Experiment1.ResultsTable = old_res;

%% Load and transform new experiment results (Experiment 2)
if exist('data_exp_58996-v8_task-f3pl.csv','file') ~= 2
    error("You have no Gorilla task results! ('data_exp_58996-v8_task-f3pl.csv')");
else
    pp_raw_results = readtable(strcat(raw_data_path, 'data_exp_58996-v8_task-f3pl.csv'));
    pp_raw_results.ANSWER = categorical(pp_raw_results.ANSWER);
end

perceiver = [];
emotionsst = [];
dv = [];

pp_ids = unique(pp_raw_results.ParticipantPrivateID);
for pp_id = 1:size(pp_ids)
    idx = pp_raw_results.ParticipantPrivateID == pp_ids(pp_id);
    copy = pp_raw_results(idx,:);
    
    idx_attempt = ~isnan(copy.Attempt);
    copy = copy(idx_attempt,:);
    
    states = {'neutral', 'happy', 'sad', 'angry'};
    for state_id = 1:size(states,2)
        idx_state = copy.ANSWER == categorical(states(state_id));
        pp_state = copy(idx_state,:);
        
        nCorrect = sum(pp_state.Correct);
        nTotal = sum(pp_state.Attempt);
        
        fprintf("pp: %d, state: %s, nTotal: %d\n", pp_id, states{state_id}, nTotal);
        if strcmp(states{state_id}, 'neutral')
            assert(nTotal == 37)
        end
        
        perceiver = [perceiver; pp_id];
        emotionsst = [emotionsst; state_id];
        dv = [dv; (nCorrect/nTotal)*100];
    end
end
a = table();
a.perceiver = categorical(perceiver);
a.emotionsst = categorical(emotionsst);
a.dv = dv;

results.Experiment2.ResultsTable = a;

if results.config.do_descriptive_stats
    %% Create descriptive statistics
    % means, std and sample size for each experiment and condition
    exp1_results = results.Experiment1.ResultsTable;
    exp2_results = results.Experiment2.ResultsTable;
    
    % sample size
    results.Experiment1.Statistics.Descriptives.n = size(exp1_results,1)/4; %number of rows / number of conditions
    results.Experiment2.Statistics.Descriptives.n = size(exp2_results,1)/4;
    
    % means, medians and standard deviation
    exp1_means = table();
    exp1_medians = table();
    exp1_std = table();
    
    exp2_means = table();
    exp2_medians = table();
    exp2_std = table();
    
    states = {"Neutral", "Happy", "Sad", "Angry"};
    for i = 1:size(states,2)
        exp1_means(:, states{i}) = array2table(mean(exp1_results(exp1_results.emotionsst == categorical(i), :).dv));
        exp1_medians(:, states{i}) = array2table(median(exp1_results(exp1_results.emotionsst == categorical(i), :).dv));
        exp1_std(:, states{i}) = array2table(std(exp1_results(exp1_results.emotionsst == categorical(i), :).dv));
        
        exp2_means(:, states{i}) = array2table(mean(exp2_results(exp2_results.emotionsst == categorical(i), :).dv));
        exp2_medians(:, states{i}) = array2table(median(exp2_results(exp2_results.emotionsst == categorical(i), :).dv));
        exp2_std(:, states{i}) = array2table(std(exp2_results(exp2_results.emotionsst == categorical(i), :).dv));
    end
    
    results.Experiment1.Statistics.Descriptives.means = exp1_means;
    results.Experiment1.Statistics.Descriptives.medians = exp1_medians;
    results.Experiment1.Statistics.Descriptives.std = exp1_std;
    
    results.Experiment2.Statistics.Descriptives.means = exp2_means;
    results.Experiment2.Statistics.Descriptives.medians = exp2_medians;
    results.Experiment2.Statistics.Descriptives.std = exp2_std;
end

if results.config.do_MannWhitneyU
    %% MannWhitney U test: once for each condition
    % Inspecting the descriptives indicated that the Experiment 1 data is
    % not normally distributed. Furthermore, sample sizes differed greatly
    % between the two groups (exp 1: n=165, exp 2: n=43).
    % Therefore, choose the non-parametrized version.
    
    states = {"Neutral", "Happy", "Sad", "Angry"};
    for i = 1:size(states,2)
        tmp = struct;
        
        x = results.Experiment1.ResultsTable(results.Experiment1.ResultsTable.emotionsst == categorical(i), :).dv;
        y = results.Experiment2.ResultsTable(results.Experiment2.ResultsTable.emotionsst == categorical(i), :).dv;
        
        if strcmp(states{i}, "Sad")
            direction = 'right';
        else
            direction = 'left';
        end
        
        [p, h, stats] = ranksum(x, y, 'tail',direction);
        
        tmp.p = p;
        tmp.h = h;
        tmp.stats = stats;
        results.Statistics.MannWhitneyU.(states{i}) = tmp;
    end
end

if results.config.do_save
    if exist(processed_data_path, 'dir') ~= 7
        mkdir(processed_data_path)
    end
    save(strcat(processed_data_path, 'results.mat'), 'results');
end
end

function results = get_results_struct()
    results = struct();
    results.config = get_config_struct();
    
    results.Experiment1 = struct;
    results.Experiment2 = struct;
    
    results.Experiment1.ResultsTable = struct;
    results.Experiment2.ResultsTable = struct; 
    
    results.Experiment2.ParticipantInfo = struct;
    
    if results.config.do_descriptive_stats
        results.Experiment1.Statistics.Descriptives = struct;
        results.Experiment2.Statistics.Descriptives = struct;
    end
    
    if results.config.do_MannWhitneyU
        results.Statistics.MannWhitneyU = struct;
        results.Statistics.MannWhitneyU.Neutral = struct;
        results.Statistics.MannWhitneyU.Happy = struct;
        results.Statistics.MannWhitneyU.Sad = struct;
        results.Statistics.MannWhitneyU.Angry = struct;
    end
end

function config = get_config_struct()
    config = struct;
    
    config.do_save = true;
    config.do_descriptive_stats = true;
    config.do_MannWhitneyU = true;
end